/* Copyright lowRISC contributors (OpenTitan project). */
/* Licensed under the Apache License, Version 2.0, see LICENSE for details. */
/* SPDX-License-Identifier: Apache-2.0 */

# Primality tests. The routines in this file are structured around `modexp` and
# make use of pre-defined memory location in `run_rsa_mem`.

.text
.globl gen_prime_candidate
.globl fermat_test
.globl miller_rabin_test

/**
 * Perform the Fermat primality test.
 *
 * This function calculates w^(p-1) mod p for some random witness w and a prime
 * candidate. If w is not divisble by p and p is prime, then w^(p-1) mod p = 1.
 * The only composite numbers that pass this test are pseudoprimes which need
 * be sieved out by an additional primality test (see miller_rabin_test).
 *
 * The test consists of a single exponentiation (i.e., one invocation of
 * `modexp`).
 *
 * @param[in] DMEM[rsa_n]: candidate prime p to check, with p = 3 mod 4.
 * @param[in]     x30: N, number of limbs of the prime
 * @param[in]     w31: all-zero
 * @param[out]     x2: result, 1 if w^(p-1) mod p else 0.
 *
 * This routine is constant-time.
 *
 * Clobbered registers: x2 to x26, x31
 *                      w2, w3, w4 to w[4+N-1], w24 to w30
 * Clobbered flag groups: FG0, FG1
 */
fermat_test:
  # Load the Montgomery constants.
  la  x16, rsa_n
  la  x17, RR
  jal x1, modload

  # Constant wide register pointers.
  li x8, 2
  li x9, 3

  # Mask the prime candidate and move it to DMEM.
  # dmem[rsa_d0] <= p ^ m
  # dmem[rsa_d1] <= m
  la x12, rsa_n
  la x13, rsa_d0
  la x14, rsa_d1
  loop x30, 6
    bn.lid  x8, 0(x12++)
    bn.wsrr w3, URND
    bn.xor  w2, w2, w3
    bn.sid  x8, 0(x13++)
    bn.xor  w31, w31, w31 # dummy instruction
    bn.sid  x9, 0(x14++)

  # Since p is odd p-1 must be even, hence to have d0 XOR d1 = p-1, the first
  # bit of the share d0 must be flipped.
  la      x12, rsa_d0
  bn.addi w3, w31, 1
  bn.lid  x8, 0(x12)
  bn.xor  w2, w2, w3
  bn.sid  x8, 0(x12)

  # Generate a witness w as the exponentation base point.
  # dmem[r0] <= w
  la  x16, r0
  la  x17, rsa_n
  jal x1, gen_witness

  # Calculate w^(p-1) mod p with message blinding is disabled.
  # dmem[r0] <= w^(p-1) mod p
  li x29, 0
  jal x1, modexp

  # Check whether w^(p-1) mod p == 1.
  la x16, r0
  jal x1, is_1

  ret

/**
 * Perform the Miller-Rabin primality test.
 *
 * Repeatedly calculate w^((p-1)/2) mod p for a random witness w and check
 * whether it equals 1 or p-1. This is a simplified variant of the algorithm of
 * Section A.1.3 of FIPS 186-5 for candidates primes of the form p mod 4 = 3 as
 * they are generated by `gen_prime_candidate`. The routine unfolds as follows:
 *
 *   x = (p-1)/2
 *   for i in num_iterations do
 *     Choose a random witness w, 1 < w < p-1
 *     y = w^x mod p
 *     if y != 1 and y != p-1 then
 *       return COMPOSITE
 *     endif
 *   endfor
 *   return PROBABLY PRIME
 *
 * This routine is constant-time with respect to p, if p is prime.
 *
 * Clobbered registers: x2 to x26, x31
 *                      w2, w3, w4 to w[4+N-1], w24 to w30
 * Clobbered flag groups: FG0, FG1
 */
miller_rabin_test:
  # Load the Montgomery constants.
  la  x16, rsa_n
  la  x17, RR
  jal x1, modload

  # Constant wide register pointers.
  li x8, 2
  li x9, 3

  # Mask the prime candidate and move it to DMEM[d0], DMEM[d1].
  # dmem[rsa_d0] <= p ^ m
  # dmem[rsa_d1] <= m
  la x12, rsa_n
  la x13, rsa_d0
  la x14, rsa_d1
  loop x30, 6
    bn.lid  x8, 0(x12++)
    bn.wsrr w3, URND
    bn.xor w2, w2, w3
    bn.sid x8, 0(x13++)
    bn.xor w31, w31, w31 # dummy instruction
    bn.sid x9, 0(x14++)

  # Since p is odd p-1 must be even, hence to have d0 XOR d1 = p-1, the first
  # bit of the share d0 must be flipped.
  # dmem[rsa_d0] <= (p-1) ^ m
  # dmem[rsa_d1] <= m
  la      x12, rsa_d0
  bn.addi w3, w31, 1
  bn.lid  x8, 0(x12)
  bn.xor  w2, w2, w3
  bn.sid  x8, 0(x12)

  # Calculate (p-1)/2 by shifting the shares one position to the right.
  # dmem[rsa_d0] <= ((p-1) ^ m) >> 1
  # dmem[rsa_d1] <= m >> 1
  la   x13, rsa_d0
  la   x14, rsa_d1
  addi x31, x30, -1
  loop x31, 9
    bn.lid  x8, 0(x13)
    bn.lid  x9, 32(x13)
    bn.rshi w2, w3, w2 >> 1
    bn.sid  x8, 0(x13++)
    bn.xor  w31, w31, w31 # dummy instruction
    bn.lid  x8, 0(x14)
    bn.lid  x9, 32(x14)
    bn.rshi w2, w3, w2 >> 1
    bn.sid  x8, 0(x14++)

  # Insert a random bit at the MSB of the shifted last word.
  bn.wsrr w3, URND
  bn.rshi w3, w3, w31 >> 1

  bn.lid  x8, 0(x13)
  bn.rshi w2, w31, w2 >> 1
  bn.or   w2, w2, w3
  bn.sid  x8, 0(x13++)
  bn.xor  w31, w31, w31 # dummy instruction
  bn.lid  x8, 0(x14)
  bn.rshi w2, w31, w2 >> 1
  bn.or   w2, w2, w3
  bn.sid  x8,  0(x14++)

  # Fix the number of iterations to 4 in accordance with Table B.1 of
  # FIPS 186-5 to reach an error probability of less than 2^100 for
  # RSA-{2048,3072,4096}.
  loopi 4, 33
    # Generate a witness w as the exponentation base point.
    # dmem[r0] <= w
    la  x16, r0
    la  x17, rsa_n
    jal x1, gen_witness

    # Calculate w^(p-1) mod p with message blinding disabled.
    # dmem[r0] <= w^(p-1) mod p
    li x29, 0
    jal x1, modexp

    # Check whether w^(p-1) mod p = 1.
    # x2 <= 1 if w^(p-1) mod p = 1 else x2 <= 0.
    la x16, r0
    jal x1, is_1

    addi x3, x2, 0

    # Check whether w^(p-1) mod p = p-1.
    # x2 <= 1 if w^(p-1) mod p = p-1 else x2 <= 0.
    la x16, r0
    la x17, rsa_n
    jal x1, is_pminus1

    # At this point, if neither w^(p-1) mod p = 1 or w^(p-1) mod p = p-1, then
    # p must be a composite number.
    or x2, x2, x3
    beq x2, x0, _miller_rabin_epilogue

    # Remask the shared exponents.
    li   x8, 2
    la   x13, rsa_d0
    la   x14, rsa_d1
    loop x30, 8
      bn.lid  x8, 0(x13)
      bn.wsrr w3, URND
      bn.xor  w2, w2, w3
      bn.sid  x8, 0(x13++)
      bn.xor  w31, w31, w31 # dummy instruction
      bn.lid  x8, 0(x14)
      bn.xor  w2, w2, w3
      bn.sid  x8, 0(x14++)
    nop

_miller_rabin_epilogue:
  ret

/**
 * Generate a n-limbed candidate prime.
 *
 * Fixes the lowest 3 bits to 1 and the highest 2 bits to 1, so the number is
 * always equivalent to 7 mod 8 and is always >= 2^(256*n - 1) * 1.5.  This
 * implies that the prime candidate is always in range, i.e. it is greater than
 * sqrt(2) * (2^(256*n - 1)), because sqrt(2) < 1.5. All other bits are fully
 * random. This follows FIPS 186-5 section A.1.3, which allows generating prime
 * candidates with a specific value mod 8 and allows the highest 2 bits to be
 * set arbitrarily.
 *
 * Flags: Flags have no meaning beyond the scope of this subroutine.
 *
 * @param[in]  x16: dptr_result, address of the result buffer in DMEM
 * @param[in]  x30: n, number of 256-bit limbs for the result
 * @param[in]  w31: all-zero
 * @param[out] dmem[x16..x16+(n*32)]: random candidate prime
 *
 * clobbered registers: x2, x3, w20, w21
 * clobbered flag groups: FG0
 */
gen_prime_candidate:
  # Constant wide register index.
  li x20, 20

  # Generate random 256-bit limbs.
  # dmem[x16..x16+(n*32)] <= RND(n*32) ^ URND(n*32)
  addi x2, x16, 0
  loop x30, 4
    bn.wsrr w20, RND      # w20 <= RND()
    bn.wsrr w21, URND     # w21 <= URND()
    bn.xor  w20, w20, w21 # w20 <= w20 ^ w21
    bn.sid  x20, 0(x2++)  # dmem[x2] <= w20

  # Fix the lowest 3 bits to 1 so the number is always 7 mod 8.
  # dmem[x16] <= dmem[x16] | 7
  bn.lid  x20, 0(x16)
  bn.addi w21, w31, 7
  bn.or   w20, w20, w21
  bn.sid  x20, 0(x16)

  # Get a pointer to the last limb.
  # x2 <= x16 + ((n-1) << 5) = x16 + (n-1)*32
  addi x31, x30, -1
  slli x3, x31, 5
  add  x2, x16, x3

  # Fix the highest 2 bits to 1.
  # dmem[x2] <= dmem[x2] | (3 << 6) << 248 = dmem[x2] | 3 << 254
  bn.lid  x20, 0(x2)
  bn.addi w21, w31, 192
  bn.or   w20, w20, w21 << 248
  bn.sid  x20, 0(x2)

  ret

/**
 * Generate a new random witness for the Fermat and Miller-Rabin tests.
 *
 * The witness w is guaranteed to been in the interval 1 < w < b-1.
 *
 * @param[in] x16, dptr_w, DMEM location to result witness w
 * @param[in] x17, dptr_b, DMEM pointer to the bound b
 * @param[in] x30, n, number of limbs
 */
gen_witness:
  li x8, 23
  li x9, 24

  # dmem[dptr_w:dptr_w+n*32] <= RND(n*32) ^ URND(n*32) = w
  addi x10, x16, 0
  loop x30, 4
    bn.wsrr w22, URND     # w22  <= URND()
    bn.wsrr w23, RND      # w23  <= RND()
    bn.xor  w23, w22, w23 # w23  <= w22 ^ w23
    bn.sid  x8, 0(x10++)  # b[i] <= w23

  bn.subi w22, w31, 1 # FG0.C <= 1

  # Check that w < b - 1.
  # FG0.C <= w <? b - FG0.C
  addi x10, x16, 0
  addi x11, x17, 0
  loop x30, 3
    bn.lid  x8, 0(x10++) # w23   <= w[i]
    bn.lid  x9, 0(x11++) # w24   <= b[i]
    bn.cmpb w23, w24     # FG0.C <= b[i] - w[i] - FG0.C

  # Extract FG0.C into a small register and jump back to the start if it is 0.
  # x2 <= CSRs[FG0][0] = FG0.C
  csrrs x2, FG0, x0
  andi  x2, x2, 1
  beq   x2, x0, gen_witness

  # Clear flags and compute the constant 1.
  # w21   <= 1
  # FG0.C <= 0
  bn.addi w22, w31, 1

  # Check that 1 < b.
  # FG0.C <= 1 <? b
  addi x10, x16, 0
  loop x30, 3
    bn.lid  x8, 0(x10++) # w23   <= b[i]
    bn.cmpb w22, w23     # FG0.C <= (i = 0 ? 1 : 0) - b[i] - FG0.C
    bn.mov  w22, w31     # w22   <= 0

  # Extract FG0.C into a small register and retry if it is 0.
  # x2 <= CSRs[FG0][0] = FG0.C
  csrrs x2, FG0, x0
  andi  x2, x2, 1
  beq   x2, x0, gen_witness

  ret

/**
 * Check whether the multi-word value x is equal to 1.
 *
 * Returns 1 in x2 if x == 1 else 0.
 *
 * @param[in]  x16: dptr_x, pointer to input buffer x in dmem
 * @param[in]  x30: n, number of limbs
 * @param[in]  w31: all-zero
 * @param[out]  x2: result, 1 if x == 1 else 0
 *
 * Clobbered Registers: x8, x9, x31, w2, w24, w25
 * Clobbered Flag Groups: FG0
 */
is_1:
  li x8, 2
  li x9, 3
  addi x10, x16, 0

  # w24 <= 2^256-1
  # w25 <= 2^256-1
  bn.sub   w24, w24, w24
  bn.not   w24, w24
  bn.mov   w25, w24

  bn.addi w4, w31, 1

  # Check all the words for equality.
  loop x30, 6
    bn.lid x8, 0(x10++)
    # For the lowest word use w4 for the comparison otherwise w3.
    # FG0.Z <= 1 if w25 = 0 else 0.
    bn.cmp w25, w31, FG0
    bn.sel w3, w31, w4, FG0.Z
    bn.xor w25, w25, w25
    # Compare for equality.
    # FG0.Z <= 1 if w2 = w3 else 0.
    bn.cmp w2, w3, FG0
    bn.sel w24, w24, w31, FG0.Z

  # Compare the result of the check to the "check passed" all-1s value.
  # FG0.Z <= (w24 == 2^256-1)
  bn.not w25, w31
  bn.cmp w25, w24

  # Get the FG0.Z flag into a register.
  # x2 <= CSRs[FG0] & 8 = FG0.Z << 3
  csrrs x2, FG0, x0
  andi  x2, x2, 8
  srli  x2, x2, 3

  ret

/**
 * Check whether the x is equal to the modulus p-1.
 *
 * Returns 1 in x2 if x == 1 else 0.
 * Note that p-1 is assumed to an even number.
 *
 * @param[in]  x16: dptr_x, pointer to input buffer x in dmem
 * @param[in]  x17: dptr_p, modulus p
 * @param[in]  x30: n, number of limbs
 * @param[out]  x2: result, 1 if x == (p-1) else 0
 *
 * Clobbered Registers: x8, x9, x10, x11, w2, w3, w24, w25
 * Clobbered Flag Groups: FG00
 */
is_pminus1:
  # Prepare DMEM and wide register pointers.
  li x8, 2
  li x9, 3
  addi x10, x16, 0
  addi x11, x17, 0

  # w24 <= 2^256-1
  # w25 <= 2^256-1
  bn.sub   w24, w24, w24
  bn.not   w24, w24
  bn.mov   w25, w24

  # Subtract 1 from the lowest word of p, which is results in p-1 since p is an
  # odd number.
  bn.lid  x9, 0(x11)
  bn.subi w4, w3, 1

  # Check all the words for equality.
  loop x30, 7
    bn.lid x8, 0(x10++)
    bn.lid x9, 0(x11++)
    # For the lowest word use w4 for the comparison otherwise w3.
    # FG0.Z <= 1 if w25 = 0 else 0.
    bn.cmp w25, w31, FG0
    bn.sel w3, w3, w4, FG0.Z
    bn.xor w25, w25, w25
    # Compare for equality.
    # FG0.Z <= 1 if w2 = w3 else 0.
    bn.cmp w2, w3, FG0
    bn.sel w24, w24, w31, FG0.Z

  # Compare the result of the check to the "check passed" all-1s value.
  # FG0.Z <= (w24 == 2^256-1)
  bn.not w25, w31
  bn.cmp w25, w24

  # Get the FG0.Z flag into a register.
  # x2 <= CSRs[FG0] & 8 = FG0.Z << 3
  csrrs x2, FG0, x0
  andi  x2, x2, 8
  srli  x2, x2, 3

  ret
